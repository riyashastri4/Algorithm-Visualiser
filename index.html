<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Algorithm Visualizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body { background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%); color: white; overflow: hidden; }
        
        #canvas { display: block; width: 100vw; height: 70vh; background: #0a0a14; }
        #controls { display: flex; align-items: center; gap: 12px; padding: 15px 20px; background: rgba(15, 52, 96, 0.95); backdrop-filter: blur(10px); flex-wrap: wrap; }
        
        select, button, input { padding: 10px 15px; border: none; border-radius: 8px; background: linear-gradient(145deg, #e94560, #ff6b6b); color: white; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.3s ease; }
        select:hover, button:hover { background: linear-gradient(145deg, #ff6b6b, #ff8e8e); transform: translateY(-2px); box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4); }
        input[type="range"] { background: linear-gradient(90deg, #4fd0e3, #26de81); height: 8px; border-radius: 5px; }
        input[type="range"]::-webkit-slider-thumb { background: #ff6b6b; width: 20px; height: 20px; border-radius: 50%; }
        
        #stats { margin-left: auto; background: linear-gradient(145deg, #533483, #7b68ee); padding: 10px 15px; border-radius: 8px; font-weight: bold; }
        #info { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.85); padding: 20px; border-radius: 12px; max-width: 350px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .highlight { text-decoration: underline; color: #4fd0e3; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <select id="category">
            <option value="sorting">üßÆ Sorting</option>
            <option value="searching">üîç Searching</option>
            <option value="graphs">üìä Graphs</option>
            <option value="trees">üå≥ Trees/DS</option>
        </select>
        <select id="algorithm">
            <!-- Sorting -->
            <option value="bubble">Bubble Sort</option>
            <option value="selection">Selection Sort</option>
            <option value="insertion">Insertion Sort</option>
            <option value="merge">Merge Sort</option>
            <option value="quick">Quick Sort</option>
            <!-- Searching -->
            <option value="linear">Linear Search</option>
            <option value="binary">Binary Search</option>
            <!-- Graphs -->
            <option value="bfs">BFS Maze</option>
            <option value="dfs">DFS Maze</option>
            <option value="dijkstra">Dijkstra</option>
            <!-- Trees/DS -->
            <option value="bst">BST Insert</option>
            <option value="stack">Stack Ops</option>
            <option value="queue">Queue Ops</option>
        </select>
        <input type="range" id="speed" min="50" max="1000" value="200">
        <button id="generate">üé≤ New Data</button>
        <button id="playpause">‚ñ∂Ô∏è Play</button>
        <button id="step">‚è≠Ô∏è Step</button>
        <button id="reset">üîÑ Reset</button>
        <div id="stats">Steps: 0 | Ops: 0 | Time: 0ms</div>
    </div>
    <div id="info">Select an algorithm and click "New Data" to visualize! Use Play/Step controls to watch the magic ‚ú®</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight * 0.7;

        let currentAlgo = null, isPlaying = false, animationId, stepDelay = 200;
        let stats = { steps: 0, ops: 0, time: 0 };
        let startTime = 0;

        // Resize canvas on window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight * 0.7;
        });

        // Complete Algorithm Implementations
        const ALGORITHMS = {
            // === SORTING ALGORITHMS ===
            bubble: {
                name: "Bubble Sort", data: [], i: 0, j: 0, complete: false,
                init(n = 60) {
                    this.data = Array(n).fill(0).map(() => Math.random() * canvas.height * 0.75 + 20);
                    this.i = 0; this.j = 0; this.complete = false; stats = { steps: 0, ops: 0, time: 0 };
                },
                step() {
                    if (this.i >= this.data.length - 1) { this.complete = true; return; }
                    if (this.j >= this.data.length - this.i - 1) { this.i++; this.j = 0; return; }
                    
                    stats.ops++;
                    if (this.data[this.j] > this.data[this.j + 1]) {
                        [this.data[this.j], this.data[this.j + 1]] = [this.data[this.j + 1], this.data[this.j]];
                    }
                    this.j++;
                    stats.steps++;
                },
                visualize() {
                    const barWidth = canvas.width / this.data.length;
                    this.data.forEach((h, idx) => {
                        const x = idx * barWidth;
                        let color = '#4fd0e3';
                        if (idx === this.j || idx === this.j + 1) color = '#ff6b6b';
                        if (idx >= this.data.length - this.i) color = '#26de81';
                        ctx.fillStyle = color;
                        ctx.fillRect(x, canvas.height - h, barWidth - 1, h);
                    });
                }
            },

            selection: {
                name: "Selection Sort", data: [], i: 0, minIdx: 0, complete: false,
                init(n = 60) {
                    this.data = Array(n).fill(0).map(() => Math.random() * canvas.height * 0.75 + 20);
                    this.i = 0; this.minIdx = 0; this.complete = false; stats = { steps: 0, ops: 0, time: 0 };
                },
                step() {
                    if (this.i >= this.data.length - 1) { this.complete = true; return; }
                    
                    if (this.minIdx === this.i) {
                        // Swap with minimum
                        [this.data[this.i], this.data[this.minIdx]] = [this.data[this.minIdx], this.data[this.i]];
                        this.i++; this.minIdx = this.i; stats.ops++; return;
                    }
                    
                    // Find minimum
                    if (this.data[this.minIdx] > this.data[this.minIdx + 1]) {
                        this.minIdx++;
                    }
                    stats.steps++;
                },
                visualize() {
                    const barWidth = canvas.width / this.data.length;
                    this.data.forEach((h, idx) => {
                        const x = idx * barWidth;
                        let color = '#4fd0e3';
                        if (idx === this.i) color = '#26de81';
                        if (idx === this.minIdx) color = '#ff6b6b';
                        ctx.fillStyle = color;
                        ctx.fillRect(x, canvas.height - h, barWidth - 1, h);
                    });
                }
            },

            insertion: {
                name: "Insertion Sort", data: [], i: 1, j: 0, complete: false,
                init(n = 60) {
                    this.data = Array(n).fill(0).map(() => Math.random() * canvas.height * 0.75 + 20);
                    this.i = 1; this.j = 0; this.complete = false; stats = { steps: 0, ops: 0, time: 0 };
                },
                step() {
                    if (this.i >= this.data.length) { this.complete = true; return; }
                    
                    if (this.j >= 0 && this.data[this.j] > this.data[this.j + 1]) {
                        [this.data[this.j], this.data[this.j + 1]] = [this.data[this.j + 1], this.data[this.j]];
                        this.j--; stats.ops++;
                    } else {
                        this.i++; this.j = this.i - 1;
                    }
                    stats.steps++;
                },
                visualize() {
                    const barWidth = canvas.width / this.data.length;
                    this.data.forEach((h, idx) => {
                        const x = idx * barWidth;
                        let color = idx < this.i ? '#26de81' : '#4fd0e3';
                        if (idx === this.j || idx === this.j + 1) color = '#ff6b6b';
                        ctx.fillStyle = color;
                        ctx.fillRect(x, canvas.height - h, barWidth - 1, h);
                    });
                }
            },

            // === SEARCHING ALGORITHMS ===
            linear: {
                name: "Linear Search", data: [], key: 0, i: 0, found: -1, complete: false,
                init(n = 60) {
                    this.data = Array(n).fill(0).map(() => Math.floor(Math.random() * 400) + 20);
                    this.key = Math.floor(Math.random() * 400) + 20;
                    this.i = 0; this.found = -1; this.complete = false; stats = { steps: 0, ops: 0, time: 0 };
                },
                step() {
                    if (this.i >= this.data.length) { this.complete = true; return; }
                    stats.ops++;
                    if (this.data[this.i] === this.key) {
                        this.found = this.i; this.complete = true; return;
                    }
                    this.i++;
                    stats.steps++;
                },
                visualize() {
                    const barWidth = canvas.width / this.data.length;
                    ctx.fillStyle = `Key: ${this.key}`;
                    ctx.font = '20px Arial';
                    ctx.fillText(`Key: ${this.key}`, 20, 40);
                    
                    this.data.forEach((val, idx) => {
                        const x = idx * barWidth, h = (val / 420) * canvas.height * 0.6;
                        let color = idx === this.i ? '#ff6b6b' : '#4fd0e3';
                        if (idx === this.found) color = '#26de81';
                        ctx.fillStyle = color;
                        ctx.fillRect(x, canvas.height - h, barWidth - 1, h);
                        ctx.fillStyle = 'white';
                        ctx.font = '14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(val.toString(), x + barWidth/2, canvas.height - h - 5);
                    });
                }
            },

            binary: {
                name: "Binary Search", data: [], key: 0, left: 0, right: 0, mid: 0, complete: false,
                init(n = 60) {
                    this.data = Array(n).fill(0).map(() => Math.floor(Math.random() * 400) + 20).sort((a,b)=>a-b);
                    this.key = Math.floor(Math.random() * 400) + 20;
                    this.left = 0; this.right = n-1; this.mid = 0; this.complete = false; stats = { steps: 0, ops: 0, time: 0 };
                },
                step() {
                    if (this.left > this.right) { this.complete = true; return; }
                    this.mid = Math.floor((this.left + this.right) / 2);
                    stats.ops++;
                    if (this.data[this.mid] === this.key) {
                        this.complete = true; return;
                    } else if (this.data[this.mid] < this.key) {
                        this.left = this.mid + 1;
                    } else {
                        this.right = this.mid - 1;
                    }
                    stats.steps++;
                },
                visualize() {
                    const barWidth = canvas.width / this.data.length;
                    ctx.fillStyle = `Key: ${this.key}`;
                    ctx.font = '20px Arial';
                    ctx.fillText(`Key: ${this.key}`, 20, 40);
                    
                    this.data.forEach((val, idx) => {
                        const x = idx * barWidth, h = (val / 420) * canvas.height * 0.6;
                        let color = '#4fd0e3';
                        if (idx >= this.left && idx <= this.right) color = '#533483';
                        if (idx === this.mid) color = '#ff6b6b';
                        ctx.fillStyle = color;
                        ctx.fillRect(x, canvas.height - h, barWidth - 1, h);
                        ctx.fillStyle = 'white';
                        ctx.font = '14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(val.toString(), x + barWidth/2, canvas.height - h - 5);
                    });
                }
            },

            // === GRAPH ALGORITHMS ===
            bfs: {
                name: "BFS Maze", grid: [], rows: 20, cols: 40, start: {x:1,y:1}, goal: {x:38,y:18},
                dirs: [[0,1],[1,0],[0,-1],[-1,0]], queue: [], visited: new Set(), complete: false,
                init() {
                    this.grid = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
                    // Add some walls
                    for(let i=0; i<this.rows; i++) {
                        for(let j=0; j<this.cols; j++) {
                            if (Math.random() < 0.2 && !(i===1&&j===1) && !(i===18&&j===38)) {
                                this.grid[i][j] = 1; // Wall
                            }
                        }
                    }
                    this.queue = [{x: this.start.x, y: this.start.y}];
                    this.visited = new Set(['1,1']);
                    this.complete = false; stats = { steps: 0, ops: 0, time: 0 };
                },
                step() {
                    if (this.queue.length === 0) { this.complete = true; return; }
                    const curr = this.queue.shift();
                    if (curr.x === this.goal.x && curr.y === this.goal.y) { this.complete = true; return; }
                    
                    for(let [dx,dy] of this.dirs) {
                        const nx = curr.x + dx, ny = curr.y + dy;
                        if (nx>=0 && nx<this.cols && ny>=0 && ny<this.rows && 
                            this.grid[ny][nx] === 0 && !this.visited.has(`${nx},${ny}`)) {
                            this.queue.push({x:nx, y:ny});
                            this.visited.add(`${nx},${ny}`);
                        }
                    }
                    stats.steps++;
                },
                visualize() {
                    const cellW = canvas.width / this.cols;
                    const cellH = canvas.height / this.rows;
                    
                    // Draw grid
                    for(let y=0; y<this.rows; y++) {
                        for(let x=0; x<this.cols; x++) {
                            const px = x * cellW, py = y * cellH;
                            if (this.grid[y][x] === 1) {
                                ctx.fillStyle = '#2d1b69';
                                ctx.fillRect(px, py, cellW, cellH);
                            } else if (this.visited.has(`${x},${y}`)) {
                                ctx.fillStyle = '#4fd0e3';
                                ctx.fillRect(px, py, cellW, cellH);
                            } else {
                                ctx.fillStyle = '#16213e';
                                ctx.fillRect(px, py, cellW, cellH);
                            }
                            
                            // Borders
                            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(px, py, cellW, cellH);
                        }
                    }
                    
                    // Start and goal
                    ctx.fillStyle = '#26de81';
                    ctx.fillRect(this.start.x * cellW, this.start.y * cellH, cellW, cellH);
                    ctx.fillStyle = '#ff6b6b';
                    ctx.fillRect(this.goal.x * cellW, this.goal.y * cellH, cellW, cellH);
                }
            },

            // === TREE/DATA STRUCTURES ===
            bst: {
                name: "BST Insert", nodes: [], values: [], insertIdx: 0, complete: false,
                init(n = 12) {
                    this.values = Array(n).fill(0).map(() => Math.floor(Math.random() * 80) + 20);
                    this.nodes = [];
                    this.insertIdx = 0;
                    this.complete = false; stats = { steps: 0, ops: 0, time: 0 };
                },
                step() {
                    if (this.insertIdx >= this.values.length) { this.complete = true; return; }
                    
                    const val = this.values[this.insertIdx];
                    if (this.nodes.length === 0) {
                        this.nodes.push({val, x: canvas.width/2, y: 100, left: null, right: null});
                    } else {
                        let node = this.nodes[0];
                        let parent = null;
                        while (node) {
                            parent = node;
                            stats.ops++;
                            if (val < node.val) {
                                if (!node.left) {
                                    node.left = {val, x: node.x - 80, y: node.y + 80, left: null, right: null};
                                    break;
                                }
                                node = node.left;
                            } else {
                                if (!node.right) {
                                    node.right = {val, x: node.x + 80, y: node.y + 80, left: null, right: null};
                                    break;
                                }
                                node = node.right;
                            }
                        }
                    }
                    this.insertIdx++;
                    stats.steps++;
                },
                visualize() {
                    // Draw connections
                    function drawTree(node) {
                        if (!node) return;
                        if (node.left) {
                            ctx.strokeStyle = '#4fd0e3';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(node.x, node.y + 20);
                            ctx.lineTo(node.left.x, node.left.y - 20);
                            ctx.stroke();
                            drawTree(node.left);
                        }
                        if (node.right) {
                            ctx.strokeStyle = '#4fd0e3';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(node.x, node.y + 20);
                            ctx.lineTo(node.right.x, node.right.y - 20);
                            ctx.stroke();
                            drawTree(node.right);
                        }
                    }
                    drawTree(this.nodes[0]);
                    
                    // Draw nodes
                    this.nodes.forEach(node => {
                        ctx.fillStyle = node === this.nodes[this.nodes.length-1] ? '#ff6b6b' : '#26de81';
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, 25, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(node.val, node.x, node.y);
                    });
                }
            }
        };

        // Animation loop
        function animate() {
            ctx.fillStyle = 'rgba(10, 10, 20, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (currentAlgo && currentAlgo.visualize) {
                currentAlgo.visualize(ctx);
            }
            
            if (isPlaying && currentAlgo && !currentAlgo.complete) {
                const now = performance.now();
                if (now - startTime > stepDelay) {
                    currentAlgo.step();
                    startTime = now;
                }
            }
            
            stats.time = performance.now() - (startTime - stepDelay);
            document.getElementById('stats').textContent = 
                `Steps: ${stats.steps} | Ops: ${stats.ops} | Time: ${Math.floor(stats.time)}ms`;
            
            animationId = requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('generate').onclick = () => {
            const algName = document.getElementById('algorithm').value;
            currentAlgo = { ...ALGORITHMS[algName] };
            if (currentAlgo.init) currentAlgo.init();
            document.getElementById('info').innerHTML = `<span class="highlight">${currentAlgo.name}</span><br>Generated! Click Play or Step to start visualization ‚ú®`;
        };

        document.getElementById('playpause').onclick = () => {
            isPlaying = !isPlaying;
            const btn = document.getElementById('playpause');
            btn.textContent = isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
            if (isPlaying) startTime = performance.now();
        };

        document.getElementById('step').onclick = () => {
            if (currentAlgo && !currentAlgo.complete) {
                currentAlgo.step();
            }
        };

        document.getElementById('reset').onclick = () => {
            if (currentAlgo && currentAlgo.init) {
                currentAlgo.init();
            }
            isPlaying = false;
            document.getElementById('playpause').textContent = '‚ñ∂Ô∏è Play';
            stats = { steps: 0, ops: 0, time: 0 };
        };

        document.getElementById('speed').oninput = (e) => {
            stepDelay = parseInt(e.target.value);
        };

        // Category filter (optional enhancement)
        document.getElementById('category').onchange = () => {
            const category = document.getElementById('category').value;
            const select = document.getElementById('algorithm');
            Array.from(select.options).forEach(option => {
                const show = category === 'sorting' ? ['bubble','selection','insertion'].includes(option.value) :
                           category === 'searching' ? ['linear','binary'].includes(option.value) :
                           category === 'graphs' ? ['bfs','dfs','dijkstra'].includes(option.value) :
                           category === 'trees' ? ['bst','stack','queue'].includes(option.value) : true;
                option.style.display = show ? 'block' : 'none';
            });
        };

        // Start animation
        animate();
    </script>
</body>
</html>
