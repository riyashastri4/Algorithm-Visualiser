<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Algorithm Visualizer</title>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; font-family:monospace; }
        body { background:#1a1a1a; color:#e0e0e0; height:100vh; display:flex; }

        /* Sidebar */
        #sidebar { width:260px; background:#2d2d2d; padding:15px; overflow-y:auto; }
        .section { margin-bottom:20px; }
        .section h3 { font-size:14px; color:#63b3ed; margin-bottom:8px; border-bottom:1px solid #444; padding-bottom:4px; }

        button { width:100%; padding:8px; margin:3px 0; background:#4a5568; color:#fff; border:none; border-radius:3px; cursor:pointer; font-size:13px; }
        button:hover { background:#63b3ed; }
        button.active { background:#4299e1; }

        input[type="range"] { width:100%; }
        label { display:block; font-size:11px; color:#a0a0a0; margin-top:5px; }

        #stats { background:#333; padding:8px; margin-top:10px; font-size:12px; border-radius:3px; }

        /* Visualizer area */
        #main { flex:1; position:relative; background:#0a0a0a; }
        #canvas { width:100%; height:100%; display:block; }

        /* C editor panel */
        #editor-container {
            position:absolute;
            right:0;
            bottom:0;
            width:360px;
            height:260px;
            background:#1e1e1e;
            border-left:1px solid #444;
            border-top:1px solid #444;
            display:flex;
            flex-direction:column;
            transition:height 0.15s linear;
        }
        #editor-header {
            padding:4px 8px;
            background:#333;
            color:#63b3ed;
            font-size:12px;
            display:flex;
            justify-content:space-between;
            align-items:center;
            cursor:pointer;
        }
        #editor-title { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
        #editor-toggle-arrow {
            font-size:12px;
            color:#ccc;
            border:none;
            background:transparent;
            cursor:pointer;
            padding:0 4px;
        }
        #editor {
            flex:1;
            width:100%;
            border:none;
            background:#1e1e1e;
            color:#fff;
            font-size:11px;
            padding:6px;
            resize:none;
        }
        #editor-container.minimized {
            height:22px;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div class="section">
            <h3>Array algorithms</h3>
            <button onclick="selectAlgo('bubble')"   id="btn-bubble">Bubble sort</button>
            <button onclick="selectAlgo('selection')"id="btn-selection">Selection sort</button>
            <button onclick="selectAlgo('insertion')"id="btn-insertion">Insertion sort</button>
            <button onclick="selectAlgo('linear')"   id="btn-linear">Linear search</button>
            <button onclick="selectAlgo('binary')"   id="btn-binary">Binary search</button>
        </div>

        <div class="section">
            <h3>Graph algorithms</h3>
            <button onclick="selectAlgo('bfs')"      id="btn-bfs">BFS</button>
            <button onclick="selectAlgo('dfs')"      id="btn-dfs">DFS</button>
            <button onclick="selectAlgo('prims')"    id="btn-prims">Prim</button>
            <button onclick="selectAlgo('kruskal')"  id="btn-kruskal">Kruskal</button>
            <button onclick="selectAlgo('dijkstra')" id="btn-dijkstra">Dijkstra</button>
        </div>

        <div class="section">
            <h3>Tree / DS</h3>
            <button onclick="selectAlgo('bst')"      id="btn-bst">BST insert</button>
        </div>

        <div class="section">
            <h3>Controls</h3>
            <button onclick="togglePlay()" id="play-btn">Play</button>
            <button onclick="doStep()">Step</button>
            <button onclick="resetAlgo()">Reset</button>
        </div>

        <div class="section">
            <h3>Settings</h3>
            <label>Speed: <span id="speedVal">200</span> ms</label>
            <input type="range" id="speed" min="50" max="1000" value="200" oninput="updateSpeed(this.value)">
            <label>Size (arrays only): <span id="sizeVal">60</span></label>
            <input type="range" id="size" min="10" max="120" value="60" oninput="updateSize(this.value)">
        </div>

        <div id="stats">Steps: 0 | Ops: 0 | Status: Ready</div>
    </div>

    <div id="main">
        <canvas id="canvas"></canvas>

        <div id="editor-container">
            <div id="editor-header" onclick="toggleEditor()">
                <span id="editor-title">C code: Bubble sort</span>
                <button id="editor-toggle-arrow" type="button">▼</button>
            </div>
            <textarea id="editor"></textarea>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = document.getElementById('main').clientWidth;
            canvas.height = document.getElementById('main').clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        let dataSize = 60;
        let stepDelay = 200;
        let isPlaying = false;
        let currentAlgoKey = 'bubble';
        let stats = { steps: 0, ops: 0 };
        let currentAlgo = null;

        function resetStats() {
            stats = { steps: 0, ops: 0 };
            updateStats('Ready');
        }

        function updateStats(status) {
            document.getElementById('stats').textContent =
                'Steps: ' + stats.steps + ' | Ops: ' + stats.ops + ' | Status: ' + status;
        }

        /* C code templates, very basic, you can edit values */
        const C_TEMPLATES = {
"bubble": `#include <stdio.h>

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = 7;
    int i, j, temp;

    for (i = 0; i < n-1; i++) {
        for (j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }

    for (i = 0; i < n; i++) printf("%d ", arr[i]);
    return 0;
}
`,
"selection": `#include <stdio.h>

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = 5;
    int i, j, minIdx, temp;

    for (i = 0; i < n-1; i++) {
        minIdx = i;
        for (j = i+1; j < n; j++) {
            if (arr[j] < arr[minIdx]) minIdx = j;
        }
        temp = arr[i];
        arr[i] = arr[minIdx];
        arr[minIdx] = temp;
    }

    for (i = 0; i < n; i++) printf("%d ", arr[i]);
    return 0;
}
`,
"insertion": `#include <stdio.h>

int main() {
    int arr[] = {12, 11, 13, 5, 6};
    int n = 5;
    int i, j, key;

    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j+1] = arr[j];
            j = j - 1;
        }
        arr[j+1] = key;
    }

    for (i = 0; i < n; i++) printf("%d ", arr[i]);
    return 0;
}
`,
"linear": `#include <stdio.h>

int main() {
    int arr[] = {5, 3, 8, 4, 2};
    int n = 5;
    int key = 4;
    int i, found = -1;

    for (i = 0; i < n; i++) {
        if (arr[i] == key) {
            found = i;
            break;
        }
    }

    if (found != -1) printf("Found at index %d\\n", found);
    else printf("Not found\\n");
    return 0;
}
`,
"binary": `#include <stdio.h>

int main() {
    int arr[] = {2, 4, 5, 8, 12, 16};
    int n = 6;
    int key = 8;
    int l = 0, r = n-1, mid, found = -1;

    while (l <= r) {
        mid = (l + r) / 2;
        if (arr[mid] == key) { found = mid; break; }
        else if (arr[mid] < key) l = mid + 1;
        else r = mid - 1;
    }

    if (found != -1) printf("Found at index %d\\n", found);
    else printf("Not found\\n");
    return 0;
}
`,
"bfs": `#include <stdio.h>

int main() {
    int n = 5;
    int g[5][5] = {
        {0,1,1,0,0},
        {1,0,1,1,0},
        {1,1,0,0,1},
        {0,1,0,0,1},
        {0,0,1,1,0}
    };
    int visited[5] = {0};
    int q[10], front = 0, rear = 0;
    int start = 0;
    int u, v;

    q[rear++] = start;
    visited[start] = 1;

    while (front < rear) {
        u = q[front++];
        printf("%d ", u);
        for (v = 0; v < n; v++) {
            if (g[u][v] && !visited[v]) {
                visited[v] = 1;
                q[rear++] = v;
            }
        }
    }
    return 0;
}
`,
"dfs": `#include <stdio.h>

void dfs(int u, int n, int g[][5], int visited[]) {
    int v;
    visited[u] = 1;
    printf("%d ", u);
    for (v = 0; v < n; v++) {
        if (g[u][v] && !visited[v]) dfs(v, n, g, visited);
    }
}

int main() {
    int n = 5;
    int g[5][5] = {
        {0,1,1,0,0},
        {1,0,1,1,0},
        {1,1,0,0,1},
        {0,1,0,0,1},
        {0,0,1,1,0}
    };
    int visited[5] = {0};
    dfs(0, n, g, visited);
    return 0;
}
`,
"prims": `#include <stdio.h>
#define INF 99999

int main() {
    int n = 5;
    int g[5][5] = {
        {0,2,0,6,0},
        {2,0,3,8,5},
        {0,3,0,0,7},
        {6,8,0,0,9},
        {0,5,7,9,0}
    };
    int selected[5] = {0};
    selected[0] = 1;
    int edges = 0, i, j;

    while (edges < n-1) {
        int min = INF, x = 0, y = 0;
        for (i = 0; i < n; i++) {
            if (selected[i]) {
                for (j = 0; j < n; j++) {
                    if (!selected[j] && g[i][j]) {
                        if (g[i][j] < min) {
                            min = g[i][j];
                            x = i; y = j;
                        }
                    }
                }
            }
        }
        printf("%d - %d (w=%d)\\n", x, y, g[x][y]);
        selected[y] = 1;
        edges++;
    }
    return 0;
}
`,
"kruskal": `#include <stdio.h>
#define INF 99999

int parent[5];

int find(int i) {
    while (parent[i] != i) i = parent[i];
    return i;
}
void uni(int i, int j) { parent[i] = j; }

int main() {
    int n = 5;
    int g[5][5] = {
        {0,2,0,6,0},
        {2,0,3,8,5},
        {0,3,0,0,7},
        {6,8,0,0,9},
        {0,5,7,9,0}
    };
    int edges = 0, i, j;

    for (i = 0; i < n; i++) parent[i] = i;

    while (edges < n-1) {
        int min = INF, a = -1, b = -1;
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                if (g[i][j] && g[i][j] < min) {
                    min = g[i][j]; a = i; b = j;
                }
            }
        }
        int u = find(a);
        int v = find(b);
        if (u != v) {
            printf("%d - %d (w=%d)\\n", a, b, g[a][b]);
            uni(u, v);
            edges++;
        }
        g[a][b] = g[b][a] = 0;
    }
    return 0;
}
`,
"dijkstra": `#include <stdio.h>
#define INF 99999

int main() {
    int n = 5;
    int g[5][5] = {
        {0,10,0,5,0},
        {10,0,1,2,0},
        {0,1,0,0,4},
        {5,2,0,0,3},
        {0,0,4,3,0}
    };
    int dist[5], visited[5] = {0};
    int i, j, u, v, min;

    for (i = 0; i < n; i++) dist[i] = INF;
    dist[0] = 0;

    for (i = 0; i < n-1; i++) {
        min = INF; u = -1;
        for (j = 0; j < n; j++) {
            if (!visited[j] && dist[j] < min) {
                min = dist[j]; u = j;
            }
        }
        if (u == -1) break;
        visited[u] = 1;
        for (v = 0; v < n; v++) {
            if (g[u][v] && dist[u] + g[u][v] < dist[v]) {
                dist[v] = dist[u] + g[u][v];
            }
        }
    }

    for (i = 0; i < n; i++)
        printf("dist[0 -> %d] = %d\\n", i, dist[i]);
    return 0;
}
`,
"bst": `#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *left, *right;
};

struct Node* newNode(int data) {
    struct Node* n = (struct Node*)malloc(sizeof(struct Node));
    n->data = data; n->left = n->right = NULL;
    return n;
}

struct Node* insert(struct Node* root, int data) {
    if (!root) return newNode(data);
    if (data < root->data) root->left = insert(root->left, data);
    else root->right = insert(root->right, data);
    return root;
}

void inorder(struct Node* root) {
    if (!root) return;
    inorder(root->left);
    printf("%d ", root->data);
    inorder(root->right);
}

int main() {
    int vals[] = {50, 30, 70, 20, 40, 60, 80};
    int n = 7, i;
    struct Node* root = NULL;
    for (i = 0; i < n; i++) root = insert(root, vals[i]);
    inorder(root);
    return 0;
}
`
        };

        /* Visual algorithms (same small fixed graphs for BFS/DFS/Prim/Kruskal/Dijkstra) */
        const ALGORITHMS = {
            bubble: {
                type: 'array',
                init() {
                    this.arr = Array(dataSize).fill(0).map(
                        () => Math.random() * canvas.height * 0.75 + 10
                    );
                    this.i = 0;
                    this.j = 0;
                    this.done = false;
                    resetStats();
                },
                step() {
                    if (this.done) return;
                    if (this.i >= this.arr.length - 1) {
                        this.done = true;
                        return;
                    }
                    if (this.j >= this.arr.length - this.i - 1) {
                        this.i++;
                        this.j = 0;
                        return;
                    }
                    stats.ops++;
                    if (this.arr[this.j] > this.arr[this.j+1]) {
                        const t = this.arr[this.j];
                        this.arr[this.j] = this.arr[this.j+1];
                        this.arr[this.j+1] = t;
                    }
                    this.j++;
                    stats.steps++;
                },
                draw() {
                    const w = canvas.width / this.arr.length;
                    for (let k = 0; k < this.arr.length; k++) {
                        let color = '#4fd0e3';
                        if (k === this.j || k === this.j+1) color = '#ff6b6b';
                        if (k >= this.arr.length - this.i) color = '#26de81';
                        ctx.fillStyle = color;
                        ctx.fillRect(k * w, canvas.height - this.arr[k], w - 1, this.arr[k]);
                    }
                }
            },

            selection: {
                type: 'array',
                init() {
                    this.arr = Array(dataSize).fill(0).map(
                        () => Math.random() * canvas.height * 0.75 + 10
                    );
                    this.i = 0;
                    this.j = 1;
                    this.minIdx = 0;
                    this.done = false;
                    resetStats();
                },
                step() {
                    if (this.done) return;
                    const n = this.arr.length;
                    if (this.i >= n - 1) {
                        this.done = true;
                        return;
                    }
                    if (this.j < n) {
                        stats.ops++;
                        if (this.arr[this.j] < this.arr[this.minIdx]) this.minIdx = this.j;
                        this.j++;
                        stats.steps++;
                    } else {
                        const t = this.arr[this.i];
                        this.arr[this.i] = this.arr[this.minIdx];
                        this.arr[this.minIdx] = t;
                        this.i++;
                        this.minIdx = this.i;
                        this.j = this.i + 1;
                    }
                },
                draw() {
                    const w = canvas.width / this.arr.length;
                    for (let k = 0; k < this.arr.length; k++) {
                        let color = '#4fd0e3';
                        if (k === this.i) color = '#26de81';
                        if (k === this.minIdx) color = '#ff6b6b';
                        ctx.fillStyle = color;
                        ctx.fillRect(k * w, canvas.height - this.arr[k], w - 1, this.arr[k]);
                    }
                }
            },

            insertion: {
                type: 'array',
                init() {
                    this.arr = Array(dataSize).fill(0).map(
                        () => Math.random() * canvas.height * 0.75 + 10
                    );
                    this.i = 1;
                    this.j = 0;
                    this.done = false;
                    resetStats();
                },
                step() {
                    if (this.done) return;
                    const n = this.arr.length;
                    if (this.i >= n) {
                        this.done = true;
                        return;
                    }
                    if (this.j >= 0 && this.arr[this.j] > this.arr[this.j+1]) {
                        const t = this.arr[this.j];
                        this.arr[this.j] = this.arr[this.j+1];
                        this.arr[this.j+1] = t;
                        this.j--;
                        stats.ops++;
                        stats.steps++;
                    } else {
                        this.i++;
                        this.j = this.i - 1;
                    }
                },
                draw() {
                    const w = canvas.width / this.arr.length;
                    for (let k = 0; k < this.arr.length; k++) {
                        let color = k < this.i ? '#26de81' : '#4fd0e3';
                        if (k === this.j || k === this.j+1) color = '#ff6b6b';
                        ctx.fillStyle = color;
                        ctx.fillRect(k * w, canvas.height - this.arr[k], w - 1, this.arr[k]);
                    }
                }
            },

            linear: {
                type: 'array',
                init() {
                    this.arr = Array(dataSize).fill(0).map(
                        () => Math.floor(Math.random() * 400) + 20
                    );
                    this.key = this.arr[Math.floor(Math.random()*this.arr.length)];
                    this.i = 0;
                    this.found = -1;
                    this.done = false;
                    resetStats();
                },
                step() {
                    if (this.done) return;
                    if (this.i >= this.arr.length) { this.done = true; return; }
                    stats.ops++;
                    if (this.arr[this.i] === this.key) {
                        this.found = this.i;
                        this.done = true;
                    }
                    this.i++;
                    stats.steps++;
                },
                draw() {
                    const w = canvas.width / this.arr.length;
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '14px monospace';
                    ctx.fillText('Key: ' + this.key, 10, 20);
                    for (let k = 0; k < this.arr.length; k++) {
                        const h = (this.arr[k] / 420) * (canvas.height * 0.6);
                        let color = '#4fd0e3';
                        if (k === this.i - 1) color = '#ff6b6b';
                        if (k === this.found) color = '#26de81';
                        ctx.fillStyle = color;
                        ctx.fillRect(k * w, canvas.height - h, w - 1, h);
                    }
                }
            },

            binary: {
                type: 'array',
                init() {
                    this.arr = Array(dataSize).fill(0).map(
                        () => Math.floor(Math.random() * 400) + 20
                    ).sort((a,b)=>a-b);
                    this.key = this.arr[Math.floor(Math.random()*this.arr.length)];
                    this.l = 0;
                    this.r = this.arr.length - 1;
                    this.mid = -1;
                    this.found = -1;
                    this.done = false;
                    resetStats();
                },
                step() {
                    if (this.done) return;
                    if (this.l > this.r) { this.done = true; return; }
                    this.mid = Math.floor((this.l + this.r) / 2);
                    stats.ops++;
                    const v = this.arr[this.mid];
                    if (v === this.key) {
                        this.found = this.mid;
                        this.done = true;
                    } else if (v < this.key) {
                        this.l = this.mid + 1;
                    } else {
                        this.r = this.mid - 1;
                    }
                    stats.steps++;
                },
                draw() {
                    const w = canvas.width / this.arr.length;
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '14px monospace';
                    ctx.fillText('Key: ' + this.key, 10, 20);
                    for (let k = 0; k < this.arr.length; k++) {
                        const h = (this.arr[k] / 420) * (canvas.height * 0.6);
                        let color = '#4fd0e3';
                        if (k >= this.l && k <= this.r) color = '#533483';
                        if (k === this.mid) color = '#ff6b6b';
                        if (k === this.found) color = '#26de81';
                        ctx.fillStyle = color;
                        ctx.fillRect(k * w, canvas.height - h, w - 1, h);
                    }
                }
            },

            /* fixed small graph for BFS, DFS, Prim, Kruskal, Dijkstra */
            bfs: {
                type: 'graph',
                init() {
                    this.buildGraph();
                    this.resetVisit();
                    this.queue = [0];
                    this.vis[0] = true;
                    this.done = false;
                    resetStats();
                },
                buildGraph() {
                    this.nodes = [
                        {x: canvas.width*0.3, y: canvas.height*0.3},
                        {x: canvas.width*0.6, y: canvas.height*0.3},
                        {x: canvas.width*0.2, y: canvas.height*0.6},
                        {x: canvas.width*0.5, y: canvas.height*0.6},
                        {x: canvas.width*0.8, y: canvas.height*0.6}
                    ];
                    this.adj = [
                        [1,2],
                        [0,3],
                        [0,3],
                        [1,2,4],
                        [3]
                    ];
                },
                resetVisit() {
                    this.vis = [false,false,false,false,false];
                    this.order = [];
                },
                step() {
                    if (this.done) return;
                    if (this.queue.length === 0) { this.done = true; return; }
                    const u = this.queue.shift();
                    this.order.push(u);
                    for (const v of this.adj[u]) {
                        if (!this.vis[v]) {
                            this.vis[v] = true;
                            this.queue.push(v);
                        }
                    }
                    stats.steps++;
                },
                draw() {
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 2;
                    for (let u = 0; u < this.nodes.length; u++) {
                        for (const v of this.adj[u]) {
                            if (v > u) {
                                const a = this.nodes[u], b = this.nodes[v];
                                ctx.beginPath();
                                ctx.moveTo(a.x, a.y);
                                ctx.lineTo(b.x, b.y);
                                ctx.stroke();
                            }
                        }
                    }
                    for (let i = 0; i < this.nodes.length; i++) {
                        const n = this.nodes[i];
                        let color = '#4fd0e3';
                        if (this.order.includes(i)) color = '#26de81';
                        ctx.beginPath();
                        ctx.arc(n.x, n.y, 18, 0, Math.PI*2);
                        ctx.fillStyle = color;
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.fillStyle = '#000';
                        ctx.font = '12px monospace';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(String(i), n.x, n.y);
                    }
                }
            },

            dfs: {
                type: 'graph',
                init() {
                    this.buildGraph();
                    this.vis = [false,false,false,false,false];
                    this.stack = [0];
                    this.order = [];
                    this.done = false;
                    resetStats();
                },
                buildGraph() {
                    this.nodes = [
                        {x: canvas.width*0.3, y: canvas.height*0.3},
                        {x: canvas.width*0.6, y: canvas.height*0.3},
                        {x: canvas.width*0.2, y: canvas.height*0.6},
                        {x: canvas.width*0.5, y: canvas.height*0.6},
                        {x: canvas.width*0.8, y: canvas.height*0.6}
                    ];
                    this.adj = [
                        [1,2],
                        [0,3],
                        [0,3],
                        [1,2,4],
                        [3]
                    ];
                },
                step() {
                    if (this.done) return;
                    if (this.stack.length === 0) { this.done = true; return; }
                    const u = this.stack.pop();
                    if (!this.vis[u]) {
                        this.vis[u] = true;
                        this.order.push(u);
                        const neighbors = [...this.adj[u]].reverse();
                        for (const v of neighbors) {
                            if (!this.vis[v]) this.stack.push(v);
                        }
                        stats.steps++;
                    }
                },
                draw() {
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 2;
                    for (let u = 0; u < this.nodes.length; u++) {
                        for (const v of this.adj[u]) {
                            if (v > u) {
                                const a = this.nodes[u], b = this.nodes[v];
                                ctx.beginPath();
                                ctx.moveTo(a.x,a.y);
                                ctx.lineTo(b.x,b.y);
                                ctx.stroke();
                            }
                        }
                    }
                    for (let i = 0; i < this.nodes.length; i++) {
                        const n = this.nodes[i];
                        let color = '#4fd0e3';
                        if (this.order.includes(i)) color = '#26de81';
                        ctx.beginPath();
                        ctx.arc(n.x, n.y, 18, 0, Math.PI*2);
                        ctx.fillStyle = color;
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.fillStyle = '#000';
                        ctx.font = '12px monospace';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(String(i), n.x, n.y);
                    }
                }
            },

            prims: {
                type: 'graph',
                init() {
                    this.buildGraph();
                    const n = this.nodes.length;
                    this.inMst = Array(n).fill(false);
                    this.inMst[0] = true;
                    this.edges = [];
                    this.stepCount = 0;
                    this.done = false;
                    resetStats();
                },
                buildGraph() {
                    this.nodes = [
                        {x: canvas.width*0.3, y: canvas.height*0.3},
                        {x: canvas.width*0.6, y: canvas.height*0.3},
                        {x: canvas.width*0.2, y: canvas.height*0.6},
                        {x: canvas.width*0.5, y: canvas.height*0.6},
                        {x: canvas.width*0.8, y: canvas.height*0.6}
                    ];
                    this.weight = [
                        [0,2,0,6,0],
                        [2,0,3,8,5],
                        [0,3,0,0,7],
                        [6,8,0,0,9],
                        [0,5,7,9,0]
                    ];
                },
                step() {
                    if (this.done) return;
                    const n = this.nodes.length;
                    if (this.edges.length >= n-1) { this.done = true; return; }
                    let min = Infinity, a=-1, b=-1;
                    for (let i=0;i<n;i++) if (this.inMst[i]) {
                        for (let j=0;j<n;j++) if (!this.inMst[j] && this.weight[i][j]>0) {
                            if (this.weight[i][j] < min) {min=this.weight[i][j]; a=i; b=j;}
                        }
                    }
                    if (a===-1) { this.done = true; return; }
                    this.inMst[b] = true;
                    this.edges.push([a,b]);
                    stats.steps++;
                },
                draw() {
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 1;
                    const n = this.nodes.length;
                    for (let i=0;i<n;i++) {
                        for (let j=i+1;j<n;j++) {
                            if (this.weight[i][j]>0) {
                                const a = this.nodes[i], b = this.nodes[j];
                                ctx.beginPath();
                                ctx.moveTo(a.x,a.y);
                                ctx.lineTo(b.x,b.y);
                                ctx.stroke();
                            }
                        }
                    }
                    ctx.strokeStyle = '#26de81';
                    ctx.lineWidth = 3;
                    for (const e of this.edges) {
                        const a = this.nodes[e[0]], b = this.nodes[e[1]];
                        ctx.beginPath();
                        ctx.moveTo(a.x,a.y);
                        ctx.lineTo(b.x,b.y);
                        ctx.stroke();
                    }
                    for (let i=0;i<n;i++) {
                        const node = this.nodes[i];
                        let color = this.inMst[i] ? '#26de81' : '#4fd0e3';
                        ctx.beginPath();
                        ctx.arc(node.x,node.y,18,0,Math.PI*2);
                        ctx.fillStyle = color;
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.fillStyle = '#000';
                        ctx.font = '12px monospace';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(String(i), node.x, node.y);
                    }
                }
            },

            kruskal: {
                type: 'graph',
                init() {
                    this.buildGraph();
                    const n = this.nodes.length;
                    this.parent = [];
                    for (let i=0;i<n;i++) this.parent[i]=i;
                    this.edgesList = [];
                    for (let i=0;i<n;i++) {
                        for (let j=i+1;j<n;j++) {
                            if (this.weight[i][j]>0) {
                                this.edgesList.push({u:i,v:j,w:this.weight[i][j]});
                            }
                        }
                    }
                    this.edgesList.sort((a,b)=>a.w-b.w);
                    this.mstEdges = [];
                    this.idx = 0;
                    this.done = false;
                    resetStats();
                },
                buildGraph() {
                    this.nodes = [
                        {x: canvas.width*0.3, y: canvas.height*0.3},
                        {x: canvas.width*0.6, y: canvas.height*0.3},
                        {x: canvas.width*0.2, y: canvas.height*0.6},
                        {x: canvas.width*0.5, y: canvas.height*0.6},
                        {x: canvas.width*0.8, y: canvas.height*0.6}
                    ];
                    this.weight = [
                        [0,2,0,6,0],
                        [2,0,3,8,5],
                        [0,3,0,0,7],
                        [6,8,0,0,9],
                        [0,5,7,9,0]
                    ];
                },
                find(x){ while (this.parent[x]!==x) x=this.parent[x]; return x; },
                unite(a,b){ this.parent[a]=b; },
                step() {
                    if (this.done) return;
                    const n=this.nodes.length;
                    if (this.mstEdges.length>=n-1 || this.idx>=this.edgesList.length) {
                        this.done=true; return;
                    }
                    const e = this.edgesList[this.idx++];
                    const u = this.find(e.u), v=this.find(e.v);
                    if (u!==v) {
                        this.unite(u,v);
                        this.mstEdges.push([e.u,e.v]);
                        stats.steps++;
                    }
                },
                draw() {
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 1;
                    const n = this.nodes.length;
                    for (let i=0;i<n;i++) {
                        for (let j=i+1;j<n;j++) {
                            if (this.weight[i][j]>0) {
                                const a=this.nodes[i], b=this.nodes[j];
                                ctx.beginPath();
                                ctx.moveTo(a.x,a.y);
                                ctx.lineTo(b.x,b.y);
                                ctx.stroke();
                            }
                        }
                    }
                    ctx.strokeStyle='#26de81';
                    ctx.lineWidth=3;
                    for (const e of this.mstEdges) {
                        const a=this.nodes[e[0]], b=this.nodes[e[1]];
                        ctx.beginPath();
                        ctx.moveTo(a.x,a.y);
                        ctx.lineTo(b.x,b.y);
                        ctx.stroke();
                    }
                    for (let i=0;i<n;i++) {
                        const node=this.nodes[i];
                        ctx.beginPath();
                        ctx.arc(node.x,node.y,18,0,Math.PI*2);
                        ctx.fillStyle='#4fd0e3';
                        ctx.fill();
                        ctx.strokeStyle='#fff';
                        ctx.lineWidth=2;
                        ctx.stroke();
                        ctx.fillStyle='#000';
                        ctx.font='12px monospace';
                        ctx.textAlign='center';
                        ctx.textBaseline='middle';
                        ctx.fillText(String(i),node.x,node.y);
                    }
                }
            },

            dijkstra: {
                type: 'graph',
                init() {
                    this.buildGraph();
                    const n=this.nodes.length;
                    this.dist = Array(n).fill(Infinity);
                    this.vis = Array(n).fill(false);
                    this.dist[0]=0;
                    this.done=false;
                    resetStats();
                },
                buildGraph() {
                    this.nodes = [
                        {x: canvas.width*0.3, y: canvas.height*0.3},
                        {x: canvas.width*0.6, y: canvas.height*0.3},
                        {x: canvas.width*0.2, y: canvas.height*0.6},
                        {x: canvas.width*0.5, y: canvas.height*0.6},
                        {x: canvas.width*0.8, y: canvas.height*0.6}
                    ];
                    this.weight = [
                        [0,10,0,5,0],
                        [10,0,1,2,0],
                        [0,1,0,0,4],
                        [5,2,0,0,3],
                        [0,0,4,3,0]
                    ];
                },
                step() {
                    if (this.done) return;
                    const n=this.nodes.length;
                    let u=-1, best=Infinity;
                    for (let i=0;i<n;i++) {
                        if (!this.vis[i] && this.dist[i]<best) {
                            best=this.dist[i]; u=i;
                        }
                    }
                    if (u===-1) { this.done=true; return; }
                    this.vis[u]=true;
                    for (let v=0; v<n; v++) {
                        if (this.weight[u][v]>0 && this.dist[u]+this.weight[u][v]<this.dist[v]) {
                            this.dist[v]=this.dist[u]+this.weight[u][v];
                        }
                    }
                    stats.steps++;
                },
                draw() {
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    ctx.strokeStyle='#555';
                    ctx.lineWidth=1;
                    const n=this.nodes.length;
                    for (let i=0;i<n;i++) {
                        for (let j=i+1;j<n;j++) {
                            if (this.weight[i][j]>0) {
                                const a=this.nodes[i], b=this.nodes[j];
                                ctx.beginPath();
                                ctx.moveTo(a.x,a.y);
                                ctx.lineTo(b.x,b.y);
                                ctx.stroke();
                            }
                        }
                    }
                    ctx.fillStyle='#ffffff';
                    ctx.font='12px monospace';
                    for (let i=0;i<n;i++) {
                        for (let j=i+1;j<n;j++) {
                            if (this.weight[i][j]>0) {
                                const a=this.nodes[i], b=this.nodes[j];
                                const mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
                                ctx.fillText(String(this.weight[i][j]), mx, my-4);
                            }
                        }
                    }
                    for (let i=0;i<n;i++) {
                        const node=this.nodes[i];
                        ctx.beginPath();
                        ctx.arc(node.x,node.y,18,0,Math.PI*2);
                        ctx.fillStyle=this.vis[i]?'#26de81':'#4fd0e3';
                        ctx.fill();
                        ctx.strokeStyle='#fff';
                        ctx.lineWidth=2;
                        ctx.stroke();
                        ctx.fillStyle='#000';
                        ctx.font='11px monospace';
                        ctx.textAlign='center';
                        ctx.textBaseline='middle';
                        ctx.fillText(i+':'+(this.dist[i]===Infinity?'inf':this.dist[i]),node.x,node.y);
                    }
                }
            },

            bst: {
                type: 'tree',
                init() {
                    this.values = [];
                    for (let i=0;i<7;i++) this.values.push(Math.floor(Math.random()*80)+10);
                    this.root=null;
                    this.insertIndex=0;
                    this.done=false;
                    resetStats();
                },
                insertVal(v) {
                    if (!this.root) {
                        this.root={val:v,x:canvas.width/2,y:80,left:null,right:null};
                        return;
                    }
                    let node=this.root;
                    while (true) {
                        stats.ops++;
                        if (v < node.val) {
                            if (!node.left) {
                                node.left={val:v,x:node.x-70,y:node.y+70,left:null,right:null};
                                return;
                            }
                            node=node.left;
                        } else {
                            if (!node.right) {
                                node.right={val:v,x:node.x+70,y:node.y+70,left:null,right:null};
                                return;
                            }
                            node=node.right;
                        }
                    }
                },
                step() {
                    if (this.done) return;
                    if (this.insertIndex >= this.values.length) { this.done=true; return; }
                    this.insertVal(this.values[this.insertIndex]);
                    this.insertIndex++;
                    stats.steps++;
                },
                drawEdges(node) {
                    if (!node) return;
                    if (node.left) {
                        ctx.strokeStyle='#4fd0e3';
                        ctx.lineWidth=2;
                        ctx.beginPath();
                        ctx.moveTo(node.x,node.y+18);
                        ctx.lineTo(node.left.x,node.left.y-18);
                        ctx.stroke();
                    }
                    if (node.right) {
                        ctx.strokeStyle='#4fd0e3';
                        ctx.lineWidth=2;
                        ctx.beginPath();
                        ctx.moveTo(node.x,node.y+18);
                        ctx.lineTo(node.right.x,node.right.y-18);
                        ctx.stroke();
                    }
                    this.drawEdges(node.left);
                    this.drawEdges(node.right);
                },
                drawNodes(node) {
                    if (!node) return;
                    this.drawNodes(node.left);
                    this.drawNodes(node.right);
                    ctx.beginPath();
                    ctx.arc(node.x,node.y,18,0,Math.PI*2);
                    ctx.fillStyle='#26de81';
                    ctx.fill();
                    ctx.strokeStyle='#fff';
                    ctx.lineWidth=2;
                    ctx.stroke();
                    ctx.fillStyle='#000';
                    ctx.font='12px monospace';
                    ctx.textAlign='center';
                    ctx.textBaseline='middle';
                    ctx.fillText(String(node.val),node.x,node.y);
                },
                draw() {
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    if (!this.root) return;
                    this.drawEdges(this.root);
                    this.drawNodes(this.root);
                }
            }
        };

        function createAlgoInstance(key) {
            const base = ALGORITHMS[key];
            const copy = {};
            for (const k in base) {
                if (typeof base[k] === 'function') {
                    copy[k] = base[k].bind(copy);
                } else {
                    copy[k] = JSON.parse(JSON.stringify(base[k]));
                }
            }
            return copy;
        }

        function selectAlgo(key) {
            currentAlgoKey = key;
            document.querySelectorAll('#sidebar button').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('btn-' + key);
            if (btn) btn.classList.add('active');
            currentAlgo = createAlgoInstance(key);
            currentAlgo.init();
            updateStats('Ready');
            const titleMap = {
                bubble:'Bubble sort', selection:'Selection sort', insertion:'Insertion sort',
                linear:'Linear search', binary:'Binary search',
                bfs:'BFS', dfs:'DFS', prims:'Prim', kruskal:'Kruskal', dijkstra:'Dijkstra',
                bst:'BST insert'
            };
            document.getElementById('editor-title').textContent = 'C code: ' + (titleMap[key] || key);
            document.getElementById('editor').value = C_TEMPLATES[key] || '';
        }

        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('play-btn').textContent = isPlaying ? 'Pause' : 'Play';
        }

        function doStep() {
            if (!currentAlgo) return;
            currentAlgo.step();
            updateStats(currentAlgo.done ? 'Done' : 'Stepping');
        }

        function resetAlgo() {
            if (!currentAlgoKey) return;
            currentAlgo = createAlgoInstance(currentAlgoKey);
            currentAlgo.init();
            isPlaying = false;
            document.getElementById('play-btn').textContent = 'Play';
        }

        function updateSpeed(v) {
            stepDelay = parseInt(v,10);
            document.getElementById('speedVal').textContent = v;
        }

        function updateSize(v) {
            dataSize = parseInt(v,10);
            document.getElementById('sizeVal').textContent = v;
            if (ALGORITHMS[currentAlgoKey].type === 'array') resetAlgo();
        }

        function animateLoop() {
            ctx.clearRect(0,0,canvas.width,canvas.height);
            if (currentAlgo && currentAlgo.draw) currentAlgo.draw();
            if (isPlaying && currentAlgo && !currentAlgo.done) {
                currentAlgo.step();
                updateStats(currentAlgo.done ? 'Done' : 'Running');
            }
            setTimeout(() => requestAnimationFrame(animateLoop), stepDelay);
        }

        function toggleEditor() {
            const cont = document.getElementById('editor-container');
            const arrow = document.getElementById('editor-toggle-arrow');
            if (cont.classList.contains('minimized')) {
                cont.classList.remove('minimized');
                arrow.textContent = '▼';
            } else {
                cont.classList.add('minimized');
                arrow.textContent = '▶';
            }
        }

        document.getElementById('editor-header').addEventListener('click', toggleEditor);

        selectAlgo('bubble');
        animateLoop();
    </script>
</body>
</html>
